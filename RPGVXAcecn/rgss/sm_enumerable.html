<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html lang=zh><head><title>Enumerable</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content=text/css http-equiv=Content-Style-Type><link rel=stylesheet
type=text/css href="../style.css">
<meta name=GENERATOR content="MSHTML 8.00.7601.17785"></head>
<body>
<h1>Enumerable</h1>
<p>包含重复关系操作类的模块，此模快的方法都是通过 each 定义的，所以包含此模块的类必须定义 each 方法。</p>
<h2>方法</h2>
<dl>
  <dt>all?
  <dt>all? {|<var>item</var>| ... }
  <dd>
  <p>当所有的项目都为真时返回 true。若任一项目为伪则返回 false。</p>
  <dd>
  <p>使用区块时，则依次以各个元素执行区块的计算，若所有的结果都是真则返回 true，一旦区块返回伪时，立刻返回 false。</p>
  <dd><pre>p [1,2,3].all? {|v| v &gt; 0}   # =&gt; true
p [1,2,3].all? {|v| v &gt; 1}   # =&gt; false
</pre>
  <dt>any?
  <dt>any? {|<var>item</var>| ... }
  <dd>
  <p>当所有的项目都为伪时返回 false。若任一项目为真则返回 true。</p>
  <p>使用区块时，则依次以各个元素执行区块的计算，若所有的结果都是伪则返回 false，一旦区块返回真时，立刻返回 true。</p><pre>p [1,2,3].any? {|v| v &gt; 3}   # =&gt; false
p [1,2,3].any? {|v| v &gt; 1}   # =&gt; true
</pre>
  <dt>collect {|<var>item</var>| ... }
  <dd>
  <p>以数组的形式返回所有区块的计算结果。</p>
  <dt>find {|<var>item</var>| ... }
  <dd>
  <p>依次以各个元素执行区块的计算，返回第一个计算为 true 的项目。若没有项目计算为 true，则返回 nil。</p>
  <dt>find_all {|<var>item</var>| ... }
  <dt>select {|<var>item</var>| ... }
  <dd>
  <p>依次以各个元素执行区块的计算，将所有计算为 true 的项目以数组形式返回。若没有项目计算为 true，则返回空数组。</p>
  <dt>include?(<var>val</var>)
  <dd>
  <p>当列表中任一项目符合 val ==&nbsp;时，返回
  true。</p>
  <dt>inject([<var>init</var>]) {|<var>result</var>, <var>item</var>| ... }
  <dd>
  <p>再执行区块之前，将 init 的初始值和一个 item 确定为参数。在第二次和随后的循环中，将上一次区块的运算结果和下一个 item
  作为参数，随后继续执行区块。最后一个 item 也作为参数后，返回最后一次区块运算得出的结果。</p>
  <p>如果一个 item 是空的，那么就返回 init&nbsp;。</p>
  <p>如果没有设置参数 <var>init</var>&nbsp;的初始值，则将第一、第二个 item 传递给区块。假如只有一个 item
  被定义的话，那么区块不会被执行，第一个 item 会被返回。如果没有 item&nbsp;被定义，那么就会返回 nil 。</p>
  <dl>
    <dt>范例
    <dd>
    <p>运算结果：</p><pre>p [1,2,3,4,5].inject(0) {|result, item| result + item }
  =&gt; 15
</pre>
    <p>它等同于下面的代码：</p><pre>result = 0
[1,2,3,4,5].each {|v| result += v }
p result
=&gt; 15
</pre></dd></dl>
  <dt>max
  <dd>
  <p>返回最大的项目，前提是所有的项目都能够使用 &lt;=&gt; 方法做比较。</p>
  <dt>max {|<var>a</var>, <var>b</var>| ... }
  <dd>
  <p>依次将各个项目与区块的计算结果比较并返回最大的项目。</p>
  <p>要求区块的计算值为：a &gt; b 时计算值为正整数、 a == b 时为 0、a &lt; b 时为负整数。若区块返回非整数数值，则抛出 <a
  href="s_exceptions.html#TypeError">TypeError</a> 异常。</p>
  <dt>max_by {|<var>item</var>| ... }
  <dd>
  <p>将各个区块的结果计算出来后，返回最大的那个项目，如果参数为空，那么就返回nil。（前提是所有的项目都能够使用 &lt;=&gt;
方法做比较。）</p>
  <dt>min
  <dd>
  <p>返回最小的项目，前提是所有的项目都能够使用 &lt;=&gt; 方法做比较。</p>
  <dt>min {|<var>a</var>, <var>b</var>| ... }
  <dd>
  <p>依次将各个项目与区块的计算结果比较并返回最小的项目。</p>
  <p>要求区块的计算值为：a &gt; b 时计算值为正整数、 a == b 时为 0、a &lt; b 时为负整数。若区块返回非整数数值，则抛出 <a
  href="s_exceptions.html#TypeError">TypeError</a> 异常。</p>
  <dt>min_by {|<var>item</var>| ... }
  <dd>
  <p>将各个区块的结果计算出来后，返回最小的那个项目，如果参数为空，那么就返回nil。（前提是所有的项目都能够使用 &lt;=&gt;
方法做比较。）</p>
  <dt>sort
  <dt>sort {|<var>a</var>, <var>b</var>| ... }
  <dd>
  <p>将所有项目依照升序排列后，生成并返回包含所有项目的数组。</p>
  <p>若没有使用区块，则调用 &lt;=&gt;&nbsp;比较来进行排序。</p>
  <p>若想调用其他非 &lt;=&gt; 的方法进行排序，就使用区块，以区块的计算结果进行排序。要求区块的计算值为：a &gt; b 时计算值为正整数、 a
  == b 时为 0、a &lt; b 时为负整数。若区块返回非整数数值，则抛出 <a
  href="s_exceptions.html#TypeError">TypeError</a> 异常。</p>
  <dt>sort_by {|<var>item</var>| ... }
  <dd>
  <p>将所有区块按照计算结果进行升序排列，生成并返回一个包含所有项目的新数组。</p>
  <dt>to_a
  <dt>entries
  <dd>
  <p>返回包含所有项目的数组。</p></dd></dl>
<h6></h6></body></html>
