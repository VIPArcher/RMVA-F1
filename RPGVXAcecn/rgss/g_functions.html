<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html lang=zh><head><title>RGSS Built-in Functions</title>
<meta content="text/html; charset=GBK" http-equiv=Content-Type>
<meta content=text/css http-equiv=Content-Style-Type><link rel=stylesheet
type=text/css href="../style.css">
<meta name=GENERATOR content="MSHTML 8.00.7601.17785"></head>
<body>
<h1>RGSS 内建函数</h1>
<p>RGSS中定义了下面的内建函数：</p>
<dl>
  <dt><a name=rgss_main>rgss_main { ... }</a> <span class=rgss3>(RGSS3)</span>
  <p></p>
  <dd>
  <p>仅进行一次加载的函数。</p>
  <p>当检测到用户按下F12的时候，这个函数会被重置。</p><pre>rgss_main { SceneManager.run }
</pre>
  <dt><a name=rgss_stop>rgss_stop</a> <span class=rgss3>(RGSS3)</span>
  <p></p>
  <dd>
  <p>停止脚本的执行，而只保留屏幕图像的刷新。关于使用的定义请查阅 <a
  href="../intro/index.html">脚本简介</a></p>
  <p>效果等效于下面这一句：</p><pre>loop { Graphics.update }
</pre>
  <dt><a name=load_data>load_data(<var>filename</var>)</a>
  <dd>
  <p>加载由 <var>filename</var> 指定的数据文件，并重建各种对象。</p><pre>$data_actors = load_data("Data/Actors.rvdata2")
</pre>这个函数本质上与下面的语句相同： <pre>File.open(filename, "rb") { |f|
  obj = Marshal.load(f)
}
</pre>
  <p>不同之处在于，本函数可以从 <a
  href="rgss.html#encryption_archive">加密文件</a>&nbsp;内加载数据文件。</p>
  <dt><a name=save_data>save_data(<var>obj</var>, <var>filename</var>)</a>
  <dd>
  <p>将对象 <var>obj</var> 写入名为 <var>filename</var> 的数据文件。</p><pre>save_data($data_actors, "Data/Actors.rvdata2")
</pre>这个函数本质上与下面的语句相同： <pre>File.open(filename, "wb") { |f|
  Marshal.dump(obj, f)
}
</pre>
  <dt><a name=msgbox>msgbox(<var>arg</var>[, ...])</a> <span
  class=rgss3>(RGSS3)</span>
  <dd>
  <p>输出一个包含参数字符串的消息框，如果参数并不是字符串的形式，则会使用 to_s 方法转换为字符串后再进行输出。</p>
  <dd>
  <p>返回值为 nil 。</p>
  <dt><a name=msgbox_p>msgbox_p(<var>obj</var>, [<var>obj2</var>, ...])</a>
  <span class=rgss3>(RGSS3)</span>
  <dd>
  <p>将 obj 以人类可读的格式输出，也就是对话显示框的形式，相当于下面的代码（具体请参看 <a
  href="sc_object.html#L000572">Object#inspect</a>&nbsp;）：</p><pre>msgbox obj.inspect, "\n", obj2.inspect, "\n", ...
</pre>
  <p>返回值为 nil 。</p></dd></dl>
<h6></h6></body></html>
